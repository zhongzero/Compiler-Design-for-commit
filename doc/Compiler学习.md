**前端** ：词法分析(Lexer)，语法分析(Parser)，语义分析(Semantic Check并收集类型信息)，中间代码生成，符号表的建立，与机器无关的中间代码优化



**后端** ：与机器相关的代码优化，目标代码的生成(包括IR->汇编代码->目标代码)，相关错误的处理，符号表的访问





* 1.写g4文件，用antlr4完成lexer和parser

* 2.完成AST，包括node(构建AST结点结构)，visitor(接口)和builder(把antlr4生成的CST转化成自己建构的AST)

  AST比CST(g4给出的) 的优势：

  1.可以删除一些无用的信息(如括号、分号等)

  2.可以将CST中的信息进行整合转化，转成更简单自己更喜欢的结构(比如可以将一些中间结点直接删去，让子孙信息直接传给父亲结点，即g4文件中为了看上去更美观加了很多无用的中间节点，这都是可以删去的)(又比如该语言的语法中有很多复杂的复合语法，完全可以把它们转换成多个简单语法) (当然，若是g4写的足够抽象，结构可以基本不变，但代码会很难看懂，因为这相当于多步合成一步来写)

  3.可以在node中加入一些自己之后可能会用到的信息(可以预处理一部分信息，用当前node中已有信息整合写出一些简单的函数，方便后面按使用)(而且比如说expr，可以增加当前expr返回的类型，是否为左右值，这是语法检查所必须的，用原来的CST基本不可能完成(除非对g4文件给出的代码进行修改，但这样显然不好))

  4.不用再一直使用antlr给出的CST的用法，可以转换成自己更熟悉的用法

  AST相当于进行一次抽象

  (可以对CST进行多次抽象，但一般抽象一次就足够了)

  (ASTbuilder时可以实现一部分简单的语法检查)

* Semantic Check 语法检查

  主要包括

  1.变量、类、函数定义是否重名

  2.变量、类、函数调用时判断是否在scope中有定义(一层层scope往上找)

  3.expr一元、二元运算符是否合法(可以在AST建树时一并实现)